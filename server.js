-- Löscht deine alte Tabelle, falls sie "friends" heißt
DROP TABLE IF EXISTS public.friends;

-- Erstellt die neue, korrekte "friends"-Tabelle
CREATE TABLE public.friends (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id_1 uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    user_id_2 uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'pending'::text,
    requested_by uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT friends_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'blocked'::text]))),
    CONSTRAINT users_unique CHECK ((user_id_1 < user_id_2))
);

-- Aktiviert Row Level Security
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;

-- Richtlinien, damit Benutzer nur ihre eigenen Freundschaften sehen können
CREATE POLICY "Benutzer können ihre eigenen Freundschaften sehen"
ON public.friends
FOR SELECT USING (
    auth.uid() = user_id_1 OR auth.uid() = user_id_2
);

CREATE POLICY "Benutzer können Freundschaftsanfragen erstellen"
ON public.friends
FOR INSERT WITH CHECK (
    auth.uid() = requested_by
);

CREATE POLICY "Benutzer können Anfragen annehmen/ablehnen/löschen"
ON public.friends
FOR UPDATE USING (
    -- Der Empfänger einer Anfrage kann sie annehmen (zu 'accepted')
    (status = 'pending' AND auth.uid() != requested_by)
) WITH CHECK (
    status = 'accepted'
);

CREATE POLICY "Benutzer können Freundschaften löschen"
ON public.friends
FOR DELETE USING (
    -- Jeder der beiden Freunde kann die Freundschaft beenden
    auth.uid() = user_id_1 OR auth.uid() = user_id_2
);